
### Title: Data Collection and Filtering: All bands
### Author: Ivan Cano
### Date: 3/5/2022
---

```import ee 
import geemap
from datetime import datetime
import numpy as np
import rasterio
import matplotlib.pyplot as plt 
import pandas as pd
from datetime import date
from datetime import timedelta
```
The following method is used too filter the tif files based on their level of cloud interference in each respective image. Filtering by clouds is accomplished by passing an image, and checking for its value associated with its meteorological disturbance.
```
 `def cloudscore(image):
        '''
        Inner function for computing cloud score such that we can remove 
        bad images from the landsat collections we download.
        Implementation in javascript can be found of Google Earth Engine 
        website under (landsat algorithms), translation to python by KH.
        Further help from Nicholas Clinton at 
        https://urldefense.com/v3/__https://gis.stackexchange.com/questions/252685/filter-landsat-images-base-on-cloud-cover-over-a-region-of-interest*5Cn__;JQ!!LLK065n_VXAQ!zP9K-68-_oPkaNWFZdbTYYnai85ggL4j3FhdqssLkim-RneBr2NqD6Ka4fu6yw-v$         '''
        cloud = ee.Algorithms.Landsat.simpleCloudScore(image).select('cloud')
        cloudiness = cloud.reduceRegion(ee.Reducer.mean(),
                                        geometry=region,
                                        scale=30)
        image = image.set(cloudiness)
        return image
```
Authentification requirements to access and initialize the google engine library

```# Trigger the authentication flow
ee.Authenticate()

# Initialize the library
ee.Initialize()
```

bbox includess the coordinates for the bounding box we will be using for our image. Each list includes a longitude and latitude for each of the quadrants of our bounding box.
```
bbox = [(115.90619263363669, 38.910654401256274),
(116.12214264584372, 38.910654401256274),
(116.12214264584372, 38.988885740039514),
(115.90619263363669, 38.988885740039514)]
```
In order to have a wide range of data points, in the form of pixels, we applied the following bands to train our model.
Bands B1 through B11 track wavelengths on the electromagnetic spectrum, and ''SAA','SZA','VAA','VZA', are values generated by shadows casted throughout various points in the day.
```
bands = ['B1','B2','B3','B4','B5','B6','B7','B8','B9','B10','B11','QA_RADSAT','SAA','SZA','VAA','VZA']
```

```
start_date = datetime(2013,3,18)

end_date = datetime(2022,2,3)

region = ee.Geometry.Polygon(bbox)

collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA').filterDate(start_date,end_date).filterBounds(region)

cloud_tol=100
collection= collection.map(algorithm=cloudscore).filter(ee.Filter.lt('cloud', cloud_tol))
```
Because of the nature of satelite images, many of them end up either clipped or corruption. This is due to a combination of instrament error and faulty correction of the shifts in space as the satelites move. Therefore as there is no parameter to test for corrupted and clipped images, a manual filter was conducted where faulty images were noted to be excluded, which were of the dates listed bellow.
```
bad_dates = ['2013-04-05',
'2013-06-13',
 '2013-06-29',
 '2013-07-31',
 '2013-09-17',
 '2013-10-19',
 '2013-12-06',
 '2014-01-07',
 '2014-02-08',
 '2014-03-12',
 '2014-05-31',
 '2014-06-16',
 '2014-08-03',
 '2014-11-07',
 '2014-12-09',
 '2015-01-26',
 '2015-06-19',
 '2015-07-21',
 '2015-09-23',
 '2016-03-17',
 '2016-04-02',
 '2016-07-07',
 '2016-07-23',
 '2016-08-08',
 '2016-09-09',
 '2016-09-25',
 '2017-02-16',
 '2017-03-20',
 '2017-06-24',
 '2017-08-11',
 '2017-09-12',
 '2017-10-14',
 '2018-01-18',
 '2018-02-19',
 '2018-05-10',
 '2018-07-29',
 '2018-09-15',
 '2018-10-17',
 '2018-12-20',
 '2019-02-22',
 '2019-04-11',
 '2019-07-16',
 '2019-10-20',
 '2020-02-09',
 '2020-05-15',
 '2020-07-02',
 '2021-01-26',
 '2021-04-16',
 '2021-08-06',
 '2021-08-22',
 '2021-09-07',
 '2021-09-23',
 '2021-10-25']

from datetime import date

list_set = []
for i in range(len(bad_dates)):   
    datetime_object = date.fromisoformat(bad_dates[i])
    start = datetime_object + timedelta(days=1)
    end = datetime_object - timedelta(days=1)
    
    list_set.append((str(start), str(end)))

for i in range(len(list_set)):
    collection = collection.filter(ee.Filter.date(list_set[i][0], list_set[i][1]).Not())
```
Selects all images based on previously implimented filters includeing, cloud, date, and band selections.
```
collection = collection.select(bands)
collection_list = collection.toList(collection.size())

collection_size = collection_list.size().getInfo()
dates = geemap.image_dates(collection, date_format='YYYY-MM-dd').getInfo()
```
The following code downloads all images into the local machine.
```
    for i, date in enumerate(dates[:]):
        
        if date in bad_dates:
            continue
            
        image = ee.Image(collection_list.get(i))


        new_image = image.select(bands)

        geemap.ee_export_image(new_image, filename = "testing_data/full_img/China_{}.tif".format(date), scale = 100, region = region, file_per_band = False)

        s_imgs.append(new_image)
```